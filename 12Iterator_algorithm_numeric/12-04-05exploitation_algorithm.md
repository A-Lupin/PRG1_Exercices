#Exploitation des possibilités de 'algorithm'



Remplacer chaque ligne contenant `//...` par une seule expression ou instruction de sorte à ce qu'elle réalise ce qui est indiqué au-dessus, soit sous la forme d'une chaîne écrite dans la console, soit sous la forme d'un commentaire.
À noter que l'instruction peut être un `if` avec déclaration (notamment si l'on veut récupérer un itérateur et l'utiliser).



~~~cpp
#include<iostream>
#include<ostream>
#include<vector>
#include<algorithm>
#include<numeric>
#include<random>
using namespace std;

ostream& operator<<(ostream & out, vector<string> v) {
  out << "[ ";
  for (const auto & e : v) out << "\"" << e << "\" ";
  out << "]\n";
  return out;
}

string gen() {
  static int i = 2;
  return to_string(567*++i%97);
}

random_device rd;
mt19937 g(rd());

int main() {
  vector<string> v {"Jean", "pierre", "la", "abcdefghij", "ngreve", "", "", "luc",
                    "France", "Italie", "", "correction", "", "mince", "", "", 
                    "gros", "Italie", "France"};
  int i = 0;
  
  cout << ++i << ") " << "Plus petite chaîne: " << 
//...
       << endl;
  cout << ++i << ") " << "Plus grande chaîne: " << 
//...
       << endl;
  cout << ++i << ") " << "Plus longue chaîne: " << 
//...
       << endl;
  
  vector<string> sans_e;
  /* Remplir sans_e avec les éléments de v non vides ne comportant pas de 'e' */
//...
 cout << ++i << ") " << sans_e;
  
  int n = 3;

  /* Remplacer les n premiers éléments de v par "XXX" */  
//...
  cout << ++i << ") " << v;

  /* Ajouter les n derniers éléments de v à la fin de v */
  v.resize(v.size() + static_cast<size_t>(n));
//...
  cout << ++i << ") "  << v;
  
  /* Remplacer les derniers éléments de v et dans l'ordre inverse, avec ceux de 
  la première moitié dont la longueur dépasse n */
//...
  cout << ++i << ") "  << v;

  /* Remplacer les n premiers éléments par ceux générés par gen() */
//...
  cout << ++i << ") "  << v;
  
  /* Écrire à l'envers l'élément de v qui précède "France" */
//...
  cout << ++i << ") "  << v;

  /* Remplacer le dernier des deux derniers éléments successifs égaux de v par "abc" */
//...
  cout << ++i << ") "  << v;

    vector<string> sub {"France", "Italie"};
  /* Renverser dans v la dernière occurrence de la sous-séquence contenue dans sub */
//...
  cout << ++i << ") " << v;

  /* Par rotation, placer en première position dans v la première occurrence de 
     la sous-séquence contenue dans sub */
//...
  cout << ++i << ") "  << v;

  /* transformer v en un palindrome, en écrasant la première moitié de ses valeurs */
//...
  cout << ++i << ") "  << v;
 
  /* Remplacer toutes les occurrences vides de v par "VIDE" */
//...
  cout << ++i << ") "  << v;
  
  /* Mélanger la seconde moitié des éléments de v */
//...
  cout << ++i << ") "  << v;

  /* Trier les élément de v par valeur non croissante */
//...
  cout << ++i << ") "  << v;
  
  /* Concaténer les éléments de sub aux premiers de v */
//...
  cout << ++i << ") "  << v;
  
  /* Supprimer de v tous ses premiers élément tant qu'il n'y en a pas 2 consécutifs égaux à "abc"*/
//...
  cout << ++i << ") "  << v;

  /* Supprimer de v tous les éléments comportant "VIDE" */
//...
  cout << ++i << ") "  << v;
  
  
  /* Supprimer de v les éléments consécutifs égaux */
//...
  cout << ++i << ") "  << v;

  cout << ++i << ") " << "Nombre de chaînes de plus de " << n << " caractères : " << 
//...
       << endl;
}
~~~

Le résultat attendu du programme est:

~~~cpp
1) Plus petite chaîne: 
2) Plus grande chaîne: pierre
3) Plus longue chaîne: abcdefghij
4) [ "la" "luc" "gros" ]
5) [ "XXX" "XXX" "XXX" "abcdefghij" "ngreve" "" "" "luc" "France" "Italie" "" "correction" "" "mince" "" "" "gros" "Italie" "France" ]
6) [ "XXX" "XXX" "XXX" "abcdefghij" "ngreve" "" "" "luc" "France" "Italie" "" "correction" "" "mince" "" "" "gros" "Italie" "France" "gros" "Italie" "France" ]
7) [ "XXX" "XXX" "XXX" "abcdefghij" "ngreve" "" "" "luc" "France" "Italie" "" "correction" "" "mince" "" "" "gros" "Italie" "Italie" "France" "ngreve" "abcdefghij" ]
8) [ "52" "37" "22" "abcdefghij" "ngreve" "" "" "luc" "France" "Italie" "" "correction" "" "mince" "" "" "gros" "Italie" "Italie" "France" "ngreve" "abcdefghij" ]
9) [ "52" "37" "22" "abcdefghij" "ngreve" "" "" "cul" "France" "Italie" "" "correction" "" "mince" "" "" "gros" "Italie" "Italie" "France" "ngreve" "abcdefghij" ]
10) [ "52" "37" "22" "abcdefghij" "ngreve" "" "" "cul" "France" "Italie" "" "correction" "" "mince" "" "" "gros" "Italie" "abc" "France" "ngreve" "abcdefghij" ]
11) [ "52" "37" "22" "abcdefghij" "ngreve" "" "" "cul" "Italie" "France" "" "correction" "" "mince" "" "" "gros" "Italie" "abc" "France" "ngreve" "abcdefghij" ]
12) [ "52" "37" "22" "abcdefghij" "ngreve" "" "" "cul" "Italie" "France" "" "correction" "" "mince" "" "" "gros" "Italie" "abc" "France" "ngreve" "abcdefghij" ]
13) [ "abcdefghij" "ngreve" "France" "abc" "Italie" "gros" "" "" "mince" "" "correction" "correction" "" "mince" "" "" "gros" "Italie" "abc" "France" "ngreve" "abcdefghij" ]
14) [ "abcdefghij" "ngreve" "France" "abc" "Italie" "gros" "VIDE" "VIDE" "mince" "VIDE" "correction" "correction" "VIDE" "mince" "VIDE" "VIDE" "gros" "Italie" "abc" "France" "ngreve" "abcdefghij" ]
15) [ "abcdefghij" "ngreve" "France" "abc" "Italie" "gros" "VIDE" "VIDE" "mince" "VIDE" "correction" "gros" "France" "VIDE" "mince" "ngreve" "Italie" "VIDE" "correction" "abc" "abcdefghij" "VIDE" ]
16) [ "ngreve" "ngreve" "mince" "mince" "gros" "gros" "correction" "correction" "abcdefghij" "abcdefghij" "abc" "abc" "VIDE" "VIDE" "VIDE" "VIDE" "VIDE" "VIDE" "Italie" "Italie" "France" "France" ]
17) [ "Francengreve" "Italiengreve" "mince" "mince" "gros" "gros" "correction" "correction" "abcdefghij" "abcdefghij" "abc" "abc" "VIDE" "VIDE" "VIDE" "VIDE" "VIDE" "VIDE" "Italie" "Italie" "France" "France" ]
18) [ "abc" "abc" "VIDE" "VIDE" "VIDE" "VIDE" "VIDE" "VIDE" "Italie" "Italie" "France" "France" ]
19) [ "abc" "abc" "Italie" "Italie" "France" "France" ]
20) [ "abc" "Italie" "France" ]
21) Nombre de chaînes de plus de 3 caractères : 2

~~~

<details>
<summary>Solution</summary>

~~~cpp
#include<iostream>
#include<ostream>
#include<vector>
#include<algorithm>
#include<numeric>
#include<random>
using namespace std;

ostream& operator<<(ostream & out, vector<string> v) {
  out << "[ ";
  for (const auto & e : v) out << "\"" << e << "\" ";
  out << "]\n";
  return out;
}

string gen() {
  static int i = 2;
  return to_string(567*++i%97);
}

random_device rd;
mt19937 g(rd());

int main() {
  vector<string> v {"Jean", "pierre", "la", "abcdefghij", "ngreve", "", "", "luc",
                    "France", "Italie", "", "correction", "", "mince", "", "", 
                    "gros", "Italie", "France"};
  int i = 0;
  
  cout << ++i << ") " << "Plus petite chaîne: " << 
       *min_element(v.begin(), v.end()) 
       << endl;
  cout << ++i << ") " << "Plus grande chaîne: " << 
       *max_element(v.begin(), v.end()) 
       << endl;
  cout << ++i << ") " << "Plus longue chaîne: " << 
    *max_element(v.begin(), v.end(), [](const string & a, const string & b){return a.size() < b.size();}) 
       << endl;
       
  // Avec un foncteur:
  struct CompareTaille {
    bool operator()(const string& a, const std::string& b) const {
        return a.size() < b.size();
    }
  };
  cout << *max_element(v.begin(), v.end(), CompareTaille() ) << endl;

  
  vector<string> sans_e;
  /* Remplir sans_e avec les éléments de v non vides ne comportant pas de 'e' */
  for_each(v.begin(), v.end(), 
           [&](const string & s){if (none_of(s.begin(), s.end(), 
                                 [](char c){return c == 'e';}) and s.size() > 0) 
                                   sans_e.push_back(s);});
  cout << ++i << ") " << sans_e;
  
  // Alternatives:
  // 1) Utilisant la méthode find de string
  copy_if(v.begin(), v.end(), back_inserter(sans_e),
    [](const string & s) {
        return s.size() > 0 && s.find('e') == string::npos;
    });
    
  // 2) Avec un foncteur
  class SansE {
    static bool contient_e(char c) {return c == 'e';}

    static bool contient_un_e(const std::string& s) {
        return std::any_of(s.begin(), s.end(), contient_e);
    }
    std::vector<std::string>& sans;
   public:
    SansE(std::vector<std::string>& sans_e) : sans(sans_e) {}
    void operator()(const std::string& s) const {
        if (s.size() > 0 && !contient_un_e(s)) {
            sans.push_back(s);
        }
    }
   private:
  };
  for_each(v.begin(), v.end(), SansE(sans_e));
  cout << sans_e;
  
  int n = 3;

  /* Remplacer les n premiers éléments de v par "XXX" */  
  fill(v.begin(), v.begin()+n, "XXX");
  cout << ++i << ") " << v;

  /* Ajouter les n derniers éléments de v à la fin de v */
  v.resize(v.size() + static_cast<size_t>(n));
  copy_backward(v.end()-2*n, v.end()-n, v.end());
  cout << ++i << ") "  << v;
  
  // Définition d'une lambda expression
  auto plus_long_que_n = [n](const string & s){return s.size() > static_cast<size_t>(n);} ;
  
  // Même chose sous la forme d'un foncteur
  struct PlusLongQue {
    int val;
    PlusLongQue(int n) : val(n) {}
    bool operator()(const std::string& s) const {
        return s.size() > static_cast<size_t>(val);
    }
  };

  /* Remplacer les derniers éléments de v et dans l'ordre inverse, avec ceux de 
  la première moitié dont la longueur dépasse n */
  copy_if(v.begin(), v.begin() + static_cast<int>(v.size())/2, v.rbegin(), plus_long_que_n);
  cout << ++i << ") "  << v;

  /* Remplacer les n premiers éléments par ceux générés par gen() */
  generate(v.begin(), v.begin()+n, gen);
  cout << ++i << ") "  << v;
  
  /* Écrire à l'envers l'élément de v qui précède "France" */
  if (auto it = find(v.begin(), v.end(), "France"s); it != v.end())
      reverse((it-1)->begin(), (it-1)->end());
  cout << ++i << ") "  << v;

  /* Remplacer le dernier des deux derniers éléments successifs égaux de v par "abc" */
  if (auto it = adjacent_find(v.rbegin(), v.rend()); it != v.rend()) 
    *it = "abc";
  cout << ++i << ") "  << v;

    vector<string> sub {"France", "Italie"};
  /* Renverser dans v la dernière occurrence de la sous-séquence contenue dans sub */
  if (auto it = find_end(v.begin(), v.end(), sub.begin(), sub.end()); it != v.end())
    reverse(it, it + static_cast<int>(sub.size()));
  cout << ++i << ") " << v;

  /* Par rotation, placer en première position dans v la première occurrence de 
     la sous-séquence contenue dans sub */
  if (auto it = search(v.begin(), v.end(), sub.begin(), sub.end()); it != v.end())
    rotate(v.begin(), it, v.end());
  cout << ++i << ") "  << v;

  /* transformer v en un palindrome, en écrasant la première moitié de ses valeurs */
  copy(v.rbegin(), v.rbegin() + static_cast<int>(v.size())/2, v.begin());
  cout << ++i << ") "  << v;
 
  /* Remplacer toutes les occurrences vides de v par "VIDE" */
  replace(v.begin(), v.end(), ""s, "VIDE"s);
  cout << ++i << ") "  << v;
  
  /* Mélanger la seconde moitié des éléments de v */
  shuffle(v.begin() + static_cast<int>(v.size())/2, v.end(), g);
  cout << ++i << ") "  << v;

  /* Trier les élément de v par valeur non croissante */
  sort(v.rbegin(), v.rend());
  cout << ++i << ") "  << v;
  
  /* Concaténer les éléments de sub aux premiers de v */
  transform(sub.begin(), sub.end(), v.begin(), v.begin(), std::plus<string>()); 
  cout << ++i << ") "  << v;
  
  /* Supprimer de v tous ses premiers élément tant qu'il n'y en a pas 2 consécutifs égaux à "abc"*/
  v.erase(v.begin(), search_n(v.begin(), v.end(), 2, "abc"));
  cout << ++i << ") "  << v;

  /* Supprimer de v tous les éléments comportant "VIDE" */
  v.erase(remove(v.begin(), v.end(), "VIDE"s), v.end());
  cout << ++i << ") "  << v;
  
  
  /* Supprimer de v les éléments consécutifs égaux */
  v.erase(unique(v.begin(), v.end()), v.end());
  cout << ++i << ") "  << v;
  
  cout << ++i << ") " << "Nombre de chaînes de plus de " << n << " caractères : " << 
    count_if(v.begin(), v.end(), PlusLongQue(n)) 
       << endl;
}
~~~

</details>
