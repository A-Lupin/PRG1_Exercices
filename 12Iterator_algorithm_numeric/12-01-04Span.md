# Span

Écrire l'implémentation d'une classe générique `Span` permettant d'attribuer des itérateurs à un tableau natif.
Le constructeur de cette classe reçoit un pointeur sur le début du tableau ainsi que l'étendue des éléments à considérer dans la séquence.
À noter que la fonction membre `data()` permet d'accéder au début d'un tableau où sont stockés les éléments d'un `vector` ou d'un `string`. 

Le code ci-après doit produire le résulat indiqué

~~~cpp
#include<utility> // Pour std::swap
// Copié de https://cplusplus.com/reference/algorithm/iter_swap/
template <class ForwardIterator1, class ForwardIterator2>
  void iter_swap (ForwardIterator1 a, ForwardIterator2 b)
{
  std::swap (*a, *b);
}
// Copié de https://cplusplus.com/reference/algorithm/reverse/
template <class BidirectionalIterator>
  void reverse (BidirectionalIterator first, BidirectionalIterator last)
{
  while ((first!=last) and (first!=--last)) {
    iter_swap(first, last);
    ++first;
  }
}

#include<iostream>
#include<vector>
int main(){
  int tab[] = {1,2,3,4,5,6,7};
  const Span st(tab, sizeof tab / sizeof(int));
  for (int i = 0; i < st.size(); ++i)
    std::cout << st[i] << ' ';
  std::cout << '\n';                             // Affiche 1 2 3 4 5 6 7
  // st[2] = 9; interdit
  for (auto i = st.begin(); i != st.end(); ++i)
    std::cout << *i << ' ';
  std::cout << '\n';                             // Affiche 1 2 3 4 5 6 7
  
  Span sst(tab + 2, 3);
  sst[2] = 9;
  for (const auto & e : sst) 
     std::cout << e << ' ';
  std::cout << '\n';                             // Affiche 3 4 9
  
  std::vector<double> v {1.,2.,3.,4.,5.,6.,7.,9.};
  Span sv(v.data(), v.size());
  reverse(sv.begin(), sv.end());
  for (const auto & e : v) 
     std::cout << e << ' ';
  std::cout << '\n';                             // Affiche 9 7 6 5 4 3 2 1
}
~~~

<details>
<summary>Solution</summary>

~~~cpp
#include<cstddef> // Pour size_t
template <typename T>
class Span {
    T* t;
    size_t n;
  public:
    explicit Span(T* ptr, size_t taille) : t(ptr), n(taille) {}
    T& operator[](int i) { return *(t + i); }
    const T operator[](int i) const {return *(t + i); } // Pour les const Span
    size_t size() const { return n; }

    class Span_iterateur {
        T* ptr;
        friend Span;
        explicit Span_iterateur(T* p) : ptr(p) {} // Constructible seulement par Span
     public:
        T & operator*() const { return *ptr; }
        Span_iterateur& operator++() { ++ptr; return *this; }
        Span_iterateur& operator--() { --ptr; return *this; }
        auto operator<=>(const Span_iterateur& right) const = default;
    };

    Span_iterateur begin() const noexcept { return Span_iterateur(t); }
    Span_iterateur end() const noexcept { return Span_iterateur(t + n); }
};
~~~
Il faut noter que cette version ne fonctionne pas directement avec les fonctions de la bibliothèque `algorithm` car cette dernière utilise des alias nommés pour les types génériques, qui doivent être incorporés dans la classe, comme par exemple `using pointer = T*;`

Il existe une variante plus simple, fonctionnelle pour cet exercice, mais qui ne se généralise pas pour la mise en œuvre d'itérateurs inverses.

~~~cpp
##include<cstddef> // Pour size_t
template <typename T>
class Span {
    T* t;
    size_t n;
  public:
    explicit Span(T* ptr, size_t taille) : t(ptr), n(taille) {}
    T& operator[](int i) { return *(t + i); }
    const T operator[](int i) const {return *(t + i); } // Pour les const Span
    size_t size() const { return n; }
  // using Span_iterateur = T*; // Si on veut écrire: for(Span::Span_iterateur i = ...
  T* begin() const noexcept {return t;}
  T* end() const noexcept {return t+n;}
};

~~~

</details>
