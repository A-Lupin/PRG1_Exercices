# Fusion alternée

Sans utiliser `<algorithm>`, écrire une fonction générique *merge* qui prend en paramètres 5 itérateurs identifiant 2 deux plages de données supposées triées et le début d'une autre plage permettant de recevoir la fusion des deux premières plages avec l'ensemble des éléments triés.

Exemple d'exécution

~~~
vector   : [11, 12, 13, 23, 25]
tableau  : [21, 22, 23, 24]
resultat : [11, 12, 13, 21, 22, 23, 23, 24, 25]
~~~

<details>
<summary>Solution</summary>

~~~cpp
#include <iostream>
#include <vector>

using namespace std;

//---------------------------------------------------------
template<typename Iterator>
void display(Iterator first, Iterator last) {
   cout << "[";
   for (Iterator it = first; it != last; ++it) {
      if (it != first) cout << ", ";
      cout << *it;
   }
   cout << "]\n";
}

//---------------------------------------------------------
template<typename Iterator1, typename Iterator2, typename Out_iterator>
Out_iterator merge(Iterator1 first1, Iterator1 last1,
                   Iterator2 first2, Iterator2 last2, Out_iterator res) {
   while (first1 != last1 and first2 != last2)
      *res++ = (*first2<*first1)? *first2++ : *first1++;

   // copie le reste de fisrst2 => last2
   if (first1 == last1)
      while (first2 != last2)
         *res++ = *first2++;

   // copie le reste de fisrst1 => last1
   else
      while (first1 != last1)
         *res++ = *first1++;

   return res;
}

//---------------------------------------------------------
int main() {

   vector v {11, 12, 13, 23, 25};
   int  t[] {21, 22, 23, 24};

   cout << "vector   : "; display(v.begin(), v.end());
   cout << "tableau  : "; display(t, t + sizeof t / sizeof(int));

   vector<int> r(v.size() + sizeof t / sizeof(int));
   merge(v.begin(), v.end(), t, t + sizeof t / sizeof(int), r.begin());

   cout << "resultat : "; display(r.begin(), r.end());
}
~~~

</details>
